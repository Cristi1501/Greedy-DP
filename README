==========================
= TUDOR Cristian - 321CB =
==========================


	Problema 1 - Frati

Am citit datele din fisierul de intrare, le-am sortat in functie de suma
elementelor (in cazul in care suma este egala selectez in functie de jocuri
pentru a sti ca mereu prima valoare ii apartine lui Jon), apoi am inceput
atribuirea numarului de jocuri si numarului de benzi celor 2 frati. In cazul in
care exista mai multe date cu suma elementelor egala parcurg acele date pastrand
indicele de inceput si cel de sfarsit al datelor cu suma egala. Pentru ca in
acest caz am facut sortarea in functie de jocuri stiu ca Jon va alege prima
valoare, iar Sam pe ultima samd. Dupa ce parcurg tot vectorul si atribui numarul
de jocuri si benzi returnez si afisez rezultatul.
In implementare am folosit scheletul din laborator modificand cele necesare
realizarii problemei. Complexitatea sortarii este O(n*logn), iar complexitatea
programului poate fi maxim (O(n) + O(n/2)), deci O(n). Pentru ca sortarea
necesita un timp mai mare rezulta ca programul are o complexitate temporala
O(n*logn). Complexitatea spatiala depinde de sortare. Ca idee, am folosit un
vector de n elemente.

	Problema 2 - Ursi

Am citit sirul din fisierul de intrare, l-am indexat de la 1 si am memorat
lungimea acestuia (fara caracterul indexat). Verific daca numarul de caciulite
este impar, daca sirul incepe cu underline, daca se termina cu underline sau
daca are mai putin de 2 caractere. Daca una din acestea este adevarata returnez
0. Daca nu returnez 0 inseamna ca sirul meu sigur incepe si se termina cu cate o
caciulita. Oricate caractere underline urmeaza dupa prima caciulita sau se afla
inaintea ultimei sigur vor forma o fata cu caciulita respectiva. Tinand cont ca
"^^" este o fata valida imi permit sa sterg acele caractere underline fara ca
rezultatul final sa fie influentat in vreun fel ("^___^_^^_^__^" va genera
acelasi rezultat ca "^^_^^_^^"). Dupa aceasta incep rezolvarea propriu zisa
folosind programarea dinamica. Stiind ca primul caracter va fi mereu caciulita
inseamna ca aceasta mereu va deschide o fata zambitoare (nu are cum sa inchida o
fata pentru ca nu are nimic inaintea sa). Din cauza indexarii de la 1 primul
camp din matrice care va avea valoarea 1 este dp[1][2]. Daca as fi indexat de la
0 ar fi fost dp[0][1], intelegandu-se ca la prima caciulita (i = 0) avem
valoarea 1  pentru ca s-a deschis o singura caciulita (j = 1), prima caciulita.
Am ales sa bordez matricea pentru a nu fi nevoit sa pun o multime de conditii
pentru evitarea iesirii din matrice. Acest lucru a avut ca efect adunarea
ambilor indici cu o unitate.
Parcurg matricea de la i = 2 (i este folosit si ca indice al liniei matricei, si
ca indice al sirului) si verific ce fel de caracter intalnesc in sir. In cazul
in care intalnesc underline pun in matrice (j-1) * dp[i-1][j]. "j-1" este din
cauza faptului ca am indexarea de la 1. Teoretic, acest lucru se traduce: daca
avem underline punem in matrice indexul unde se afla caracterul '_' inmultit cu
valoarea anterioara obtinuta, adica se pot forma maxim n fete zambitoare, unde n
este numarul de caciulite pana la acest underline. Daca mai avem un underline
inmultim din nou cu indexul samd. In cazul in care intalnesc caciulita avem doua
situatii: situatia cand caciulita deschide o noua fata si cand caciulita inchide
o fata zambitoare. Astfel, in matrice vom pune suma celor doua cazuri.
Aceasta problema am rezolvat-o dupa ce mi-a explicat un coleg cum sta treaba cu
acele sume si dupa ce am observat discutiile de pe forum. De asemenea, am
inteles si modul de functionare al recurentei. Sper ca am explicat bine si a
inteles toata lumea! :D
Complexitatea temporala a programului este O(n^2) deorece parcurg cu doua
for-uri pana la n, iar cea spatiala este tot O(n^2) pentru ca folosesc o matrice
pentru determinarea rezultatului.

	Problema 3 - Planificare

Asa cum probabil se observa si la celalte doua probleme am pastrat notatiile
date in enunt de aceea structura contine L si N (si nu pierdere_toatala sau
nr_concursuri). Pentru mine a fost mai usor de urmarit variabilele stiind
enuntul temei. Prima rezolvare pe care am implementat-o avea la baza o matrice
din care foloseam doar partea superioara (asa cum se poate observa in submisiile
anterioare). Din cauza faptului ca primeam TLE la ultimul test pe vmchecker a
trebuit sa modific implementarea si sa folosesc un vector. Insa am reusit sa
pastrez ideea pe care am avut-o la baza cand am scris algoritmul. In cele ce
urmeaza o sa explic ideea doar pentru cazul acesta in care folosesc vectorul
pentru a se intelege mai usor si implementarea. Primul for il folosesc pentru
parcurgerea tuturor probelor, iar al doilea pentru parcurgerea probelor de la
cea curenta si pana la final (sau pana cand mai am ce scadea din "rest"). Plec
de la prima proba si verific cate astfel de probe pot incapea in acel concurs.
Cand nu mai incap probe ma opresc. Daca au incaput cel putin doua probe inseamna
ca atunci cand voi creste index-ul voi avea ceva pe pozitia dp[2]. Daca pe dp[2]
intalnesc ceva pus anterior sunt nevoit sa imi calculez "drumul minim". Folosesc
aceasta notatie deoarece eu am interpretat aceasta problema ca pe cea a
costurilor. Astfel, pornind de la inceput, pentru a ajunge in pozitia 2 am doua
optiuni: fie adun pierderea actuala cu cea a concursului precedent (dp[1]), fie
pastrez valoarea deja existenta in dp[2] care reprezinta drumul de la 1 la 2.
Pe scurt, fac minimul dintre suma pierderii actuale cu pierderea anterioara si
valoarea deja existenta in acel camp. Daca nu am nimic in acel camp folosesc
direct suma descrisa anterior. Astfel, daca nu modific campul in ceea ce
priveste pierderea, nu voi modifica nici numarul de concursuri pentru ca asta
inseamna ca acea proba a incaput in concursul anterior. Pe scurt, cand se
modifica pierderea se incrementeaza si concursul. La final returnez ultimul
obiect din vector si afisez cele doua rezultate.
Din cauza (sau datorita, depinde) parcurgerii pe care o fac complexitatea
temporala a programului (worst-case, daca toate probele ar incapea intr-un
singur concurs) este O(p*(p+1) / 2), adica O(p^2), iar cea spatiala este O(p)
pentru ca folosesc un vector de p elemente pentru determinarea solutiei.

	Problema 4 - Numaratoare

Fiind o problema bonus m-am gandit ca aceasta se rezolva cu backtracking pentru
ca ar fi in plus fata de tema propriu zisa (DP & Greedy). Astfel am inceput
implementarea unui backtracking. Dupa ce am terminat am observat ca primesc TLE
la mai multe teste. Asa ca am inceput sa optimizez pe cat de mult posibil ideea
initiala. Astfel, am ajuns la o simpla recursivitate care merge direct catre
solutia finala fara a mai pierde timpul cu solutiile care sigur nu duc catre
ceva bun. Pentru asta am folosit variabila "sum" care imi calculeaza suma pana
la un anumit moment si cateva formule matematice pentru evitarea unor rezultate
gresite, altele decat cele dorite. Astfel, programul meu genereaza mereu
urmatorul element din suma folosindu-se de "sum" si fara a folosi ideea initiala
de backtracking. Deci la final a iesit doar o simpla recursivitate dupa parerea
mea.
Apelez functia back si incep generarea elementelor sumei. Variabila "elems" imi
retine indexul elementelor sumei pentru a sti cand suma are exact n termeni (am
folosit ideea aceea de la backtracking cu start si stop din laborator), iar
variabila "sum" memoreaza suma acelor elems+1 termeni pentru a-mi usura calculul
pe parcurs. Cand ma aflu la primul termen elems si sum vor fi 0, astfel ca v[0]
va memora s-n+1 (dupa cateva calcule matematice am ajuns la aceasta formula).
Dupa aceea, urmatoarele rezultate ar fi generate dupa formula s-sum-n+elems+1,
insa doar partial. Daca am avea o suma de genul "11=4+3+2+1+1" si index-ul ei nu
ar fi cel cerut, algoritmul isi opreste completarea sumei la intalnirea primei
valoare 1 pentru ca stiu sigur ca urmeaza doar elemente 1 pana la final. Daca
index-ul este cel cerut isi va continua completarea, iar la final se va face
verificarea, va fi bine si se va termina executia. De asemenea, daca prin calcul
as obtine un j mai mare decat cel anterior aleg valoarea precedenta sa o adaug
in suma. Asta inseamna ca in loc de "8=3+4+1" voi avea "8=3+3+..." (aici va urma
2, bineinteles) care este corecta. In cazul in care ies din recursivitate si am
j = 2 nu voi lasa algoritmul sa ruleze pentru j = 1 pentru ca ar genera o
solutie gresita (exemplu, "11=4+3+2+1+1", daca atunci cand m-as intoarce in 2 as
scadea la 1, pentru realizarea unei sume corecte as fi nevoit sa pun un 2 pe una
dintre cele doua pozitii ramase, ceea ce ar fi eronat, nerespectandu-se ordinea
descrescatoare).
Astfel, algoritmul parcurge doar o parte din solutiile pe care le formeaza, fara
a duce la final decat pe cea necesara. Prin aceste optimizari am reusit sa scot
un timp foarte mic dupa parerea mea. Am mai auzit cativa colegi care spuneau ca
au rezolvat aceasta problema folosind o matrice tridimensionala, insa mi s-a
parut mai ok solutia aceasta si nu am mai modificat-o.
Deoarece parcurg doar pana intalnesc j = 1 rezulta ca la prima solutie fac doar
o iteratie, apoi fac doua samd. Complexitatea temporala maxima ar fi O(n^2).
Recunosc, imi e putin greu sa calculez complexitatea asta. Depinde mult de
input, dar banuiesc ca aceea ar fi pentru ca plec de la 1 si ajung la n daca am
solutie (deci ar fi O(n*(n+1) / 2)). Complexitatea spatiala este O(n) pentru ca
folosesc doar un vector de n elemente.


Sper ca am explicat cat se poate de clar implementarea aleasa, sper sa se
inteleaga! :)